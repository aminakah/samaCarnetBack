import { DateTime } from 'luxon'
import { BaseModel, column, belongsTo, beforeSave, computed } from '@adonisjs/lucid/orm'
import type { BelongsTo } from '@adonisjs/lucid/types/relations'
import { v4 as uuidv4 } from 'uuid'
import Tenant from './tenant.js'

import VaccineType from './vaccine_type.js'
// import User from './user.js' // Temporairement commenté pour éviter l'erreur circulaire

/**
 * VaccineSchedule model for managing vaccination schedules
 * Supports automatic generation and reminder systems
 */
export default class VaccineSchedule extends BaseModel {
  @column({ isPrimary: true })
  declare id: number

  // Tenant and patient relationships
  @column()
  declare tenantId: number

  @column()
  declare patientId: number

  @column()
  declare vaccineTypeId: number

  // Schedule information
  @column()
  declare doseNumber: number

  @column.date()
  declare scheduledDate: DateTime

  @column.date()
  declare dueDate: DateTime

  @column.date()
  declare earliestDate: DateTime | null

  // Age-based scheduling
  @column()
  declare scheduledAgeMonths: number | null

  @column()
  declare scheduledAgeDays: number | null

  // Special considerations
  @column()
  declare isCatchUp: boolean

  @column()
  declare isBooster: boolean

  @column()
  declare isSeasonal: boolean

  @column()
  declare seasonYear: number | null

  // Pregnancy-related scheduling
  @column()
  declare pregnancyId: number | null

  @column()
  declare gestationalWeek: number | null

  // Schedule status
  @column()
  declare status: 'scheduled' | 'due' | 'overdue' | 'completed' | 'missed' | 'contraindicated' | 'deferred'

  @column()
  declare notes: string | null

  @column()
  declare deferralReason: string | null

  @column.date()
  declare rescheduledDate: DateTime | null

  // Reminders and notifications
  @column()
  declare reminderSent: boolean

  @column.dateTime()
  declare reminderSentAt: DateTime | null

  @column()
  declare reminderCount: number

  @column.date()
  declare nextReminderDate: DateTime | null

  // Healthcare provider assignment
  @column()
  declare assignedProviderId: number | null

  // Auto-generation tracking
  @column()
  declare autoGenerated: boolean

  @column()
  declare generationRule: string | null

  @column({
    prepare: (value: any) => value ? JSON.stringify(value) : null,
    consume: (value: string | null) => (value ? JSON.parse(value) : null) as any,
  })
  declare generationParameters: Record<string, any> | null

  // Priority and urgency
  @column()
  declare priority: 'low' | 'normal' | 'high' | 'urgent'

  @column()
  declare isMandatory: boolean

  @column()
  declare priorityReason: string | null

  // Dependencies
  @column({
    prepare: (value: any) => value ? JSON.stringify(value) : null,
    consume: (value: string | null) => (value ? JSON.parse(value) : null) as any,
  })
  declare prerequisites: number[] | null

  @column()
  declare canCoAdminister: boolean

  @column({
    prepare: (value: any) => value ? JSON.stringify(value) : null,
    consume: (value: string | null) => (value ? JSON.parse(value) : null) as any,
  })
  declare contraindicatedWith: number[] | null

  // Sync and versioning
  @column()
  declare syncId: string

  @column()
  declare version: number

  @column.dateTime()
  declare lastSyncAt: DateTime | null

  @column()
  declare isSynced: boolean

  @column({
    prepare: (value: any) => value ? JSON.stringify(value) : null,
    consume: (value: string | null) => (value ? JSON.parse(value) : null) as any,
  })
  declare pendingChanges: Record<string, any> | null

  // Audit fields
  @column()
  declare createdBy: number | null

  @column()
  declare updatedBy: number | null

  @column.dateTime({ autoCreate: true })
  declare createdAt: DateTime

  @column.dateTime({ autoCreate: true, autoUpdate: true })
  declare updatedAt: DateTime

  @column.dateTime()
  declare deletedAt: DateTime | null

  // Relationships
  @belongsTo(() => Tenant)
  declare tenant: BelongsTo<typeof Tenant>

  @belongsTo(() => User, {
    foreignKey: 'patientId',
  })
  declare patient: BelongsTo<typeof User>

  @belongsTo(() => VaccineType)
  declare vaccineType: BelongsTo<typeof VaccineType>


  @belongsTo(() => User, {
    foreignKey: 'assignedProviderId',
  })
  declare assignedProvider: BelongsTo<typeof User>

  @belongsTo(() => User, {
    foreignKey: 'createdBy',
  })
  declare creator: BelongsTo<typeof User>

  @belongsTo(() => User, {
    foreignKey: 'updatedBy',
  })
  declare updater: BelongsTo<typeof User>

  // Hooks
  @beforeSave()
  static async generateSyncId(schedule: VaccineSchedule) {
    if (schedule.$isNew && !schedule.syncId) {
      schedule.syncId = uuidv4()
    }
  }

  @beforeSave()
  static async updateStatus(schedule: VaccineSchedule) {
    if (schedule.status === 'scheduled' || schedule.status === 'due') {
      const now = DateTime.now()
      const daysPastDue = now.diff(schedule.dueDate, 'days').days

      if (daysPastDue > 30) {
        schedule.status = 'overdue'
      } else if (daysPastDue > 0) {
        schedule.status = 'due'
      } else {
        schedule.status = 'scheduled'
      }
    }
  }

  @beforeSave()
  static async incrementVersion(schedule: VaccineSchedule) {
    if (!schedule.$isNew && Object.keys(schedule.$dirty).length > 0) {
      schedule.version = (schedule.version || 1) + 1
      schedule.isSynced = false
      schedule.lastSyncAt = DateTime.now()
    }
  }

  // Computed properties
  @computed()
  get daysPastDue(): number {
    return Math.ceil(DateTime.now().diff(this.dueDate, 'days').days)
  }

  @computed()
  get daysUntilDue(): number {
    return Math.ceil(this.dueDate.diff(DateTime.now(), 'days').days)
  }

  @computed()
  get isOverdue(): boolean {
    return this.daysPastDue > 0 && ['scheduled', 'due', 'overdue'].includes(this.status)
  }

  @computed()
  get isDue(): boolean {
    const days = this.daysUntilDue
    return days <= 7 && days >= 0 && ['scheduled', 'due'].includes(this.status)
  }

  @computed()
  get urgencyLevel(): 'low' | 'medium' | 'high' | 'critical' {
    if (this.isOverdue && this.daysPastDue > 60) return 'critical'
    if (this.isOverdue && this.daysPastDue > 30) return 'high'
    if (this.isOverdue || this.isDue) return 'medium'
    return 'low'
  }

  @computed()
  get canBeAdministered(): boolean {
    const now = DateTime.now()
    
    // Check if within administration window
    if (this.earliestDate && now < this.earliestDate) return false
    if (this.status === 'completed') return false
    if (this.status === 'contraindicated') return false
    
    // Check if not too late (configurable grace period)
    const gracePeriodDays = this.isMandatory ? 90 : 60
    if (this.daysPastDue > gracePeriodDays) return false
    
    return true
  }

  /**
   * Mark as completed
   */
  async markAsCompleted(): Promise<void> {
    this.status = 'completed'
    await this.save()
  }

  /**
   * Defer vaccination
   */
  async defer(reason: string, newDate?: DateTime): Promise<void> {
    this.status = 'deferred'
    this.deferralReason = reason
    if (newDate) {
      this.rescheduledDate = newDate
      this.scheduledDate = newDate
      this.dueDate = newDate.plus({ days: 7 }) // 7-day grace period
    }
    await this.save()
  }

  /**
   * Mark as contraindicated
   */
  async markAsContraindicated(reason: string): Promise<void> {
    this.status = 'contraindicated'
    this.deferralReason = reason
    await this.save()
  }

  /**
   * Reschedule vaccination
   */
  async reschedule(newDate: DateTime, reason?: string): Promise<void> {
    this.scheduledDate = newDate
    this.dueDate = newDate.plus({ days: 7 })
    this.rescheduledDate = newDate
    this.status = 'scheduled'
    if (reason) {
      this.notes = (this.notes || '') + `\nRescheduled: ${reason}`
    }
    await this.save()
  }

  /**
   * Send reminder notification
   */
  async sendReminder(): Promise<void> {
    this.reminderSent = true
    this.reminderSentAt = DateTime.now()
    this.reminderCount += 1
    
    // Schedule next reminder based on urgency
    const daysUntilNext = this.isDue ? 1 : this.isOverdue ? 1 : 7
    this.nextReminderDate = DateTime.now().plus({ days: daysUntilNext })
    
    await this.save()
  }

  /**
   * Check prerequisites
   */
  async checkPrerequisites(): Promise<{ met: boolean; missing: number[] }> {
    if (!this.prerequisites || this.prerequisites.length === 0) {
      return { met: true, missing: [] }
    }

    // Get completed vaccinations for this patient (vaccination feature removed)
    // Since vaccination table was removed, assume no vaccinations are completed
    const completedVaccinations: any[] = []
    const completedVaccineTypeIds: number[] = []
    const missingPrerequisites = this.prerequisites.filter(
      id => !completedVaccineTypeIds.includes(id)
    )

    return {
      met: missingPrerequisites.length === 0,
      missing: missingPrerequisites
    }
  }

  /**
   * Get next dose in series
   */
  async getNextDoseInSeries(): Promise<VaccineSchedule | null> {
    return await VaccineSchedule.query()
      .where('tenant_id', this.tenantId)
      .where('patient_id', this.patientId)
      .where('vaccine_type_id', this.vaccineTypeId)
      .where('dose_number', this.doseNumber + 1)
      .whereNull('deleted_at')
      .first()
  }

  /**
   * Generate next dose schedule
   */
  async generateNextDose(): Promise<VaccineSchedule | null> {
    await this.load('vaccineType')
    
    const nextDoseNumber = this.doseNumber + 1
    if (nextDoseNumber > this.vaccineType.dosesRequired) {
      return null // Series complete
    }

    const interval = this.vaccineType.getNextDoseInterval(this.doseNumber)
    if (!interval) return null

    const nextScheduledDate = this.scheduledDate.plus({ days: interval })
    
    const nextDose = new VaccineSchedule()
    nextDose.tenantId = this.tenantId
    nextDose.patientId = this.patientId
    nextDose.vaccineTypeId = this.vaccineTypeId
    nextDose.doseNumber = nextDoseNumber
    nextDose.scheduledDate = nextScheduledDate
    nextDose.dueDate = nextScheduledDate.plus({ days: 7 })
    nextDose.autoGenerated = true
    nextDose.generationRule = 'next_dose_in_series'
    nextDose.generationParameters = { 
      previousScheduleId: this.id,
      intervalDays: interval 
    }
    nextDose.assignedProviderId = this.assignedProviderId
    nextDose.priority = this.priority
    nextDose.isMandatory = this.isMandatory
    
    await nextDose.save()
    return nextDose
  }

  /**
   * Find due schedules for tenant
   */
  static async findDueForTenant(tenantId: number, days: number = 7) {
    const endDateISO = DateTime.now().plus({ days }).toISODate()
    
    if (!endDateISO) {
      throw new Error('Invalid end date for vaccine schedule query')
    }
    
    return await VaccineSchedule.query()
      .where('tenant_id', tenantId)
      .whereIn('status', ['scheduled', 'due'])
      .where('due_date', '<=', endDateISO)
      .whereNull('deleted_at')
      .preload('patient' as any)
      .preload('vaccineType' as any)
      .preload('assignedProvider' as any)
      .orderBy('due_date', 'asc')
      .orderBy('priority_level', 'desc')
  }

  /**
   * Find overdue schedules for tenant
   */
  static async findOverdueForTenant(tenantId: number) {
    const nowISO = DateTime.now().toISODate()
    
    if (!nowISO) {
      throw new Error('Invalid date for overdue vaccine schedule query')
    }
    
    return await VaccineSchedule.query()
      .where('tenant_id', tenantId)
      .whereIn('status', ['scheduled', 'due', 'overdue'])
      .where('due_date', '<', nowISO)
      .whereNull('deleted_at')
      .preload('patient' as any)
      .preload('vaccineType' as any)
      .orderBy('due_date', 'asc')
  }

  /**
   * Find schedules needing reminders
   */
  static async findNeedingReminders(tenantId: number) {
    const reminderDateISO = DateTime.now().toISODate()
    
    if (!reminderDateISO) {
      throw new Error('Invalid date for reminder vaccine schedule query')
    }
    
    return await VaccineSchedule.query()
      .where('tenant_id', tenantId)
      .whereIn('status', ['scheduled', 'due', 'overdue'])
      .where((query) => {
        query
          .where('reminder_sent', false)
          .orWhere('next_reminder_date', '<=', reminderDateISO)
      })
      .whereNull('deleted_at')
      .preload('patient' as any)
      .preload('vaccineType' as any)
  }

  /**
   * Generate patient vaccination schedule
   */
  static async generatePatientSchedule(
    tenantId: number, 
    patientId: number, 
    birthDate: DateTime,
    pregnancyId?: number
  ): Promise<VaccineSchedule[]> {
    // Get all vaccine types for patient's age group
    const ageInMonths = DateTime.now().diff(birthDate, 'months').months
    const targetGroup = ageInMonths < 12 ? 'infant' : 
                       ageInMonths < 144 ? 'child' : 
                       ageInMonths < 216 ? 'adolescent' : 'adult'

    const vaccineTypes = await VaccineType.findForTargetGroup(targetGroup)
    const schedules: VaccineSchedule[] = []

    for (const vaccineType of vaccineTypes) {
      if (!vaccineType.isSuitableForAge(ageInMonths)) continue

      for (let doseNumber = 1; doseNumber <= vaccineType.dosesRequired; doseNumber++) {
        const interval = vaccineType.getNextDoseInterval(doseNumber - 1) || 0
        const scheduledDate = birthDate.plus({ 
          months: vaccineType.minAgeMonths || 0,
          days: interval * (doseNumber - 1)
        })

        // Don't schedule past vaccinations
        if (scheduledDate < DateTime.now().minus({ days: 30 })) continue

        const schedule = new VaccineSchedule()
        schedule.tenantId = tenantId
        schedule.patientId = patientId
        schedule.vaccineTypeId = vaccineType.id
        schedule.doseNumber = doseNumber
        schedule.scheduledDate = scheduledDate
        schedule.dueDate = scheduledDate.plus({ days: 14 })
        schedule.earliestDate = scheduledDate.minus({ days: 3 })
        schedule.autoGenerated = true
        schedule.generationRule = 'patient_schedule_generation'
        schedule.priority = vaccineType.isMandatory ? 'high' : 'normal'
        schedule.isMandatory = vaccineType.isMandatory

        if (pregnancyId && vaccineType.targetGroup === 'pregnant_women') {
          schedule.pregnancyId = pregnancyId
        }

        await schedule.save()
        schedules.push(schedule)
      }
    }

    return schedules
  }
}
